//------------------------------------------------
//--- 010 Editor v7.0.2 Binary Template
//
//      File: Anim.bt
//   Authors: jonwd7
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

typedef struct {
    SSTRING name;
    Ref object;
} AVOBJ <name="AV Object", open=true>;

typedef struct {
    NIOBJECT
    Ref scene;
    uint numObjs;
    if ( numObjs > 0 )
        AVOBJ object[numObjs] <optimize=false>;
} NiAVObjPalette <name="NiDefaultAVObjectPalette">;

typedef struct {
    NIOBJECT
    Ref nextController;
    ushort flags;
    float frequency;
    float phase;
    float startTime;
    float stopTime;
    Ref target;
} NiTimeController <open=true>; // Abstract

typedef NiTimeController NiInterpController <open=true>; // Abstract

typedef struct {
    NiTimeController controller;
    Ref interpolator;
} NiSingleInterpController <open=true>; // Abstract

typedef NiSingleInterpController NiFloatInterpController <open=true>; // Abstract
typedef NiSingleInterpController NiBoolInterpController <open=true>; // Abstract
typedef NiSingleInterpController NiExtraDataController <open=true>; // Abstract

typedef enum <ushort> { TC_AMBIENT, TC_DIFFUSE, TC_SPECULAR, TC_SELF_ILLUM } TargetColor;

typedef struct {
    NiSingleInterpController controller;
    TargetColor targetColor;
} NiLightColorCtlr <name="NiLightColorController">;

typedef NiBoolInterpController NiVisCtlr <name="NiVisController", open=false>;

typedef struct {
    NiExtraDataController controller;
    STRING extraData;
} NiFloatEDCtlr <name="NiFloatExtraDataController">;

typedef struct {
    // NiControllerSequence::InterpArrayItem
    Ref interpolator;
    Ref controller;
    if ( BSStream() )
        byte priority;
    if ( version < Version(10, 1, 0, 111) ) {
        Ref blendInterp;
        ushort blendIndex;
    }
    // NiControllerSequence::IDTag
    if ( version >= Version(10, 2, 0, 0) && version < Version(20, 1, 0, 1) ) {
        Ref palette; // NiStringPalette
        Ref AVObjectName;
        Ref propertyType;
        Ref controllerType;
        Ref controllerID;
        Ref interpolatorID;
    } else {
        STRING AVObjectName;
        STRING propertyType;
        STRING controllerType;
        STRING controllerID;
        STRING interpolatorID;
    }
} ControlledBlock <name="Controlled Block">;

typedef enum <uint> { LOOP, REVERSE, CLAMP, MAX_CYCLE_TYPES } CycleType;

typedef struct {
    NIOBJECT
    STRING name;
    if ( DIV2 ) {
        uint numUnkInt;
        if ( numUnkInt > 0 )
            uint unkInt[numUnkInt];
        Ref unkRef;
    }
    uint numBlocks;
    uint arrayGrowBy;
    if ( numBlocks > 0 )
        if ( version < V10_2_0_0 ) // Should not be optimized < 10.2
            ControlledBlock block[numBlocks] <optimize=false>;
        else
            ControlledBlock block[numBlocks] <optimize=true>;

    float weight;
    Ref textKey;
    CycleType cycleType;
    float frequency;
    if ( version < Version(10, 3, 0, 1) )
        float phase;
    float beginKeyTime;
    float endKeyTime;
    Ref owner; // NiControllerManager
    STRING accumRootName;
    if ( version >= Version(20, 3, 0, 8) )
        uint flags;
    if ( version >= Version(10, 1, 0, 113) && version < Version(20, 1, 0, 1) )
        Ref palette; // NiStringPalette

    if ( stream > 11 && stream <= 28 )
        Ref animNotes; // BSAnimNotes
    else if ( stream > 28 )
        RefArray16 animNotes( "Anim Notes" ) <optimize=false>; // BSAnimNotes.. Multidimensional?
} NiControllerSequence <name="NiControllerSequence">;

typedef struct {
    NiTimeController controller;
    bool cumulativeAnim;
    RefArray sequence( "Sequence" ); // NiSequence
    Ref objectPalette;
} NiControllerMgr <name="NiControllerManager">;

typedef struct {
    NIOBJECT
    BinaryData data;
    uint dataEnd;
} NiStringPalette <name="NiStringPalette">;

typedef struct {
    NiTimeController controller;
    Ref interpolator; // NiKeyframeData
} NiTransCtlr <name="NiTransformController">;

typedef struct {
    NiInterpController controller;
    RefArray16 targets( "Target" ); // NiAVObject
} NiMultiTransCtlr <name="NiMultiTargetTransformController">;

typedef struct {
    NiFloatInterpController controller;
    uint affectedMap;
    RefArray textures( "Texture" ); // NiTexture
} NiFlipController <name="NiFlipController">;

typedef struct {
    NiInterpController controller;
    uint count;
    RefArray interpolators( "Interpolator" );
    StringArray targetNames;
} NiMorphWeightsController <name="NiMorphWeightsController">;

typedef struct {
    NiTimeController controller;
    int lod;
    uint numLODs;
    uint numBones;
    if ( numBones > 0 )
        RefArray nodeSets( "Bone" )[numBones] <optimize=false>; // NiNode
    
    // There are no signs of a minimum version for these values in Gamebryo
    // but they are not present in Bethesda NIFs. The XML uses == 20.3.0.9
    // which is incorrect because Gamebryo says it should always be present.
    if ( !BSStream() ) {
        uint numSkins;
        if ( numSkins > 0 ) {
            struct {
                uint size;
                if ( size > 0 ) {
                    Ref skinGeometry[size]; // NiTriBasedGeom
                    Ref skinInstance[size]; // NiSkinInstance
                }
            } skinInfos[numSkins] <optimize=false>;
        }
        RefArray skins( "Skin" ); // NiTriBasedGeom
    }
} NiBoneLODController <name="NiBoneLODController">;

typedef NiBoneLODController NiBSBoneLODCtlr <name="NiBSBoneLODController">;

typedef struct {
    NiTimeController controller;
    Ref interpolator; // NiFloatInterpolator
} BSFrustumCtlr <name="BSFrustumFOVController">;

typedef struct {
    NiFloatInterpController controller;
    BSLSPControlledVariable controlledVariable;
} BSLSPFloatCtlr <name="BSLightingShaderPropertyFloatController">;

typedef struct {
    NiFloatInterpController controller;
    BSLSPControlledColor controlledColor;
} BSLSPColorCtlr <name="BSLightingShaderPropertyColorController">;

typedef struct {
    NiFloatInterpController controller;
    BSESPControlledVariable controlledVariable;
} BSESPFloatCtlr <name="BSEffectShaderPropertyFloatController">;

typedef struct {
    NiFloatInterpController controller;
    BSESPControlledColor controlledColor;
} BSESPColorCtlr <name="BSEffectShaderPropertyColorController">;

typedef NiFloatInterpController NiAlphaCtlr <name="NiAlphaController", open=false>;
typedef NiAlphaCtlr BSNiAlphaCtlr <name="BSNiAlphaPropertyTestRefController", open=false>;

typedef NiFloatInterpController NiLightRadiusCtlr <name="NiLightRadiusController", open=false>;
typedef NiFloatInterpController NiLightDimmerCtlr <name="NiLightDimmerController", open=false>;

// BSLagBoneController
typedef struct {
    NiTimeController controller;
    float linearVelocity;
    float linearRotation;
    float maxDistance;
} BSLagBoneCtlr <name="BSLagBoneController">;

// BSProceduralLightningController
typedef struct {
    NiTimeController controller;
    Ref generationInterp;
    Ref mutationInterp;
    // Generation
    Ref subdivisionInterp;
    Ref numBranchesInterp;
    Ref numBranchesVarInterp;
    // Process
    Ref lengthInterp;
    Ref lengthVarInterp;
    Ref widthInterp;
    Ref arcOffsetInterp;
    // Generation Params
    ushort subdivisions;
    ushort numBranches;
    ushort numBranchesVariation;
    // Process Params
    float length;
    float lengthVariation;
    float width;
    float childWidthMult;
    float arcOffset;
    bool fadeMainBolt;
    bool fadeChildBolts;
    bool animateArcOffset;
    Ref shaderProperty;
} BSPLightningCtlr <name="BSProceduralLightningController">;

// DATA

typedef struct {
    NIOBJECT
    uint numRotKeys;
    if ( numRotKeys > 0 )
    {
        KeyType rotType;
        if ( rotType != XYZ_ROTATION_KEY )
            Vec4Key rotations(rotType)[numRotKeys] <optimize=true>;
        else if ( rotType == XYZ_ROTATION_KEY ) {
            FloatKeyGrp rotations[3] <optimize=false>;
        }
            
    }
    Vec3KeyGrp translations;
    FloatKeyGrp scales;
} NiKFData <name="NiKeyFrameData">;

typedef struct {
    NiKFData data;
} NiTransformData <name="NiTransformData">;

typedef struct {
    NIOBJECT
    Vec3KeyGrp positions;
} NiPosData <name="NiPosData">;

typedef struct {
    NIOBJECT
    ByteKeyGrp data;
} NiByteData;
typedef NiByteData NiBoolData <name="NiBoolData">;

typedef struct {
    NIOBJECT
    FloatKeyGrp data;
} NiFloatData <name="NiFloatData">;

typedef struct {
    NIOBJECT
    uint numControlPoints;
    if ( numControlPoints > 0 )
        float controlPoints[numControlPoints];
    uint numCompactControlPoints;
    if ( numCompactControlPoints > 0 )
        short compactControlPoints[numCompactControlPoints];
} NiBSplineData <name="NiBSplineData">;

typedef struct {
    NIOBJECT
    uint quantity;
} NiBSplineBasisData <name="NiBSplineBasisData">;


// INTERPOLATORS

typedef struct {
    NIOBJECT
} NiInterpolator <name="NiInterpolator">; // Abstract

#define NIINTERP NiInterpolator base;

typedef struct {
    NIINTERP
    enum <byte> { MANAGER_CONTROLLED = 1 } flags;
    byte arraySize;
    float weightThreshold;
    if ( !(flags & 1) ) {
        byte interpCount;
        byte singleIndex;
        char highPriority;
        char nextHighPriority;
        float singleTime;
        float highSumOfWeights;
        float nextHighSumOfWeights;
        float highEaseSpinner;
        if ( arraySize ) {
            struct {
                Ref interpolator;
                float weight;
                float normalizedWeight;
                byte priority;
                float easeSpinner;
            } interpArrayItem[arraySize] <optimize=true>;
        }
    }
} NiBlendInterpolator <name="NiBlendInterpolator", open=true>; // Abstract

typedef struct {
    NIINTERP
} NiKeyBasedInterpolator <name="NiKeyBasedInterpolator">; // Abstract

#define NIBLENDINTERP NiBlendInterpolator base;
#define NIKBINTERP NiKeyBasedInterpolator base;

typedef struct {
    NIKBINTERP
    byte value; // NiBool value of 2 means Invalid, basically the "undefined" value like uint/float
    Ref data; // NiBoolData
} NiBoolInterp <name="NiBoolInterpolator">;

typedef NiBoolInterp NiBoolTimeInterp <name="NiBoolTimelineInterpolator">;

typedef struct {
    NIBLENDINTERP
    byte value;
} NiBlendBool <name="NiBlendBoolInterpolator">;

typedef struct {
    NIKBINTERP
    float value;
    Ref data; // NiFloatData
} NiFloatInterp <name="NiFloatInterpolator">;

typedef struct {
    NIBLENDINTERP
    float value;
} NiBlendFloat <name="NiBlendFloatInterpolator">;

typedef struct {
    NIKBINTERP
    NiQuatTransform transform;
    Ref data; // NiTransformData
} NiTransformInterp <name="NiTransformInterpolator">;

typedef struct {
    NIKBINTERP
    Vec3 point;
    Ref data; // NiPosData
} NiPoint3Interp <name="NiPoint3Interpolator">;

typedef struct {
    NIBLENDINTERP
    Vec3 point;
} NiBlendPoint3 <name="NiBlendPoint3Interpolator">;

typedef struct {
    NIKBINTERP
    enum <ushort> {
        LOOK_X_AXIS = 0,
        LOOK_FLIP = 1,
        LOOK_Y_AXIS = 2,
        LOOK_Z_AXIS = 4
    } flags; // Should be a bitfield for flip toggle
    Ref lookAt;
    STRING lookAtName;
    NiQuatTransform transform;
    Ref translateInterp;
    Ref rollInterp;
    Ref scaleInterp;
} NiLookAtInterp <name="NiLookAtInterpolator">;

// TODO: Needs to be changed to bitfield
typedef enum <ushort> {
    CVDataNeedsUpdate = 0x1,
    CurveTypeOpen = 0x2,
    AllowFlip = 0x4,
    Bank = 0x8,
    ConstantVelocity = 0x10,
    Follow = 0x20,
    Flip = 0x40
} PathFlags;

// NiPathInterpolator
typedef struct {
    NIKBINTERP
    PathFlags flags;
    uint bankDir;
    float maxBankAngle;
    float smoothing;
    ushort followAxis;
    Ref pathData; // NiPosData
    Ref percentData; // NiFloatData
} NiPathInterp <name="NiPathInterpolator">;

// NiBSplineInterpolator
typedef struct {
    NIINTERP
    float startTime;
    float endTime;
    Ref data; // NiBSplineData
    Ref basisData; // NiBSplineBasisData
} NiBSplineInterpolator <name="NiBSplineInterpolator">;

typedef struct {
    NiBSplineInterpolator base;
    float value;
    uint valueHandle;
} NiBSplineFloatInterpolator <name="NiBSplineFloatInterpolator">;

typedef struct {
    NiBSplineInterpolator base;
    NiQuatTransform transform;
    uint transCPHandle;
    uint rotationCPHandle;
    uint scaleCPHandle;
} NiBSplineTransformInterpolator <name="NiBSplineTransformInterpolator">;

typedef struct {
    NiBSplineInterpolator base;
    Vec3 value;
    uint valueHandle;
} NiBSplinePoint3Interpolator <name="NiBSplinePoint3Interpolator">;

typedef struct {
    NiBSplineFloatInterpolator base;
    float compScalars[2];
} NiBSplineCompFloatInterpolator <name="NiBSplineCompFloatInterpolator">;

typedef struct {
    NiBSplineTransformInterpolator base;
    float compScalars[6];
} NiBSplineCompTransformInterpolator <name="NiBSplineCompTransformInterpolator">;

typedef struct {
    NiBSplinePoint3Interpolator base;
    float compScalars[2];
} NiBSplineCompPoint3Interpolator <name="NiBSplineCompPoint3Interpolator">;


// Legacy Anim

typedef NiFloatInterpController NiAlphaController <name="NiAlphaController", open=false>;
typedef NiFloatInterpController BSMatEmitMultCtlr <name="BSMaterialEmittanceMultController", open=false>;
typedef NiFloatInterpController BSRefractionStrCtlr <name="BSRefractionStrengthController", open=false>;
typedef NiLightColorCtlr NiMaterialColorCtlr <name="NiMaterialColorController">;

typedef struct {
    NiFloatInterpController controller;
    byte unkByte;
    uint texType;
    uint texTransType;
} NiTextureTransformCtlr <name="NiTextureTransformController">;

typedef struct ( uint numVerts ) {
    STRING frameName;
    if ( !BS_OBL && version < Version(20, 1, 0, 3) )
        float weight;
    if ( numVerts > 0 )
        Vec3 vector[numVerts];
} Morph;

typedef struct {
    NIOBJECT
    uint numMorphs;
    uint numVertices;
    bool relativeTargets;
    if ( numMorphs > 0 )
        Morph morph(numVertices)[numMorphs] <optimize=false>;
} NiMorphData <name="NiMorphData">;

typedef struct {
    NIOBJECT
    Vec4KeyGrp data; // Color4
} NiColorData <name="NiColorData">;

typedef struct {
    NiInterpController controller;
    ushort flags; // flags & 1 == updateNormals
    Ref data; // NiMorphData
    bool alwaysUpdate;

    if ( version >= Version(10, 1, 0, 104) ) {
        if ( version < Version(20, 1, 0, 3) ) {
            RefArray interpolators( "Interpolator" ); // NiInterpolator
            if ( BS_OBL ) {
                uint numUnk;
                if ( numUnk > 0 )
                    float unk[numUnk];
            }
        } else {
            uint numTargets;
            if ( numTargets > 0 )
                struct {
                    Ref interpolator;
                    float weight;
                } interpItem[numTargets];
        }
    }
} NiGeomMorpherCtlr <name="NiGeomMorpherController">;

typedef struct {
    NiTimeController controller;
    uint keys;
} bhkBlendController <name="bhkBlendController">;

typedef enum<uint> {
    ANT_INVALID = 0,
    ANT_GRABIK = 1,
    ANT_LOOKIK = 2
} AnimNoteType;

typedef struct {
    NIOBJECT
    AnimNoteType type; // BSAnimNote::AnimNoteType
    float time;
    if ( type == ANT_GRABIK )
        uint arm; // GRABIK_ARM
    if ( type != ANT_INVALID ) {
        float gain;
        uint state; // GRABIK_STATE / LOOKIK_STATE
    }
} BSAnimNote <name="BSAnimNote">;

typedef struct {
    NIOBJECT
    RefArray16 animNotes( "Anim Note" ); // BSAnimNote
} BSAnimNotes <name="BSAnimNotes">;

