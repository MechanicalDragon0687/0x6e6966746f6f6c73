//------------------------------------------------
//--- 010 Editor v7.0.2 Binary Template
//
//      File: Anim.bt
//   Authors: jonwd7
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

typedef struct {
    SSTRING name;
    Ref object;
} AVOBJ <name="AV Object", open=true>;

typedef struct {
    Ref scene;
    uint numObjs;
    if ( numObjs > 0 )
        AVOBJ object[numObjs] <optimize=false>;
} NiAVObjPalette <name="NiDefaultAVObjectPalette">;

typedef struct {
    Ref nextController;
    ushort flags;
    float frequency;
    float phase;
    float startTime;
    float stopTime;
    Ref target;
} NITIMECTLR <open=true>; // Abstract

typedef NITIMECTLR NIINTERPCTLR <open=true>; // Abstract

typedef struct {
    NITIMECTLR controller;
    Ref interpolator;
} NISINGLEINTERPCTLR <open=true>; // Abstract

typedef NISINGLEINTERPCTLR NIFLOATINTERPCTLR <open=true>; // Abstract
typedef NISINGLEINTERPCTLR NIBOOLINTERPCTLR <open=true>; // Abstract
typedef NISINGLEINTERPCTLR NIEXTRADATACTLR <open=true>; // Abstract

typedef enum <ushort> { TC_AMBIENT, TC_DIFFUSE, TC_SPECULAR, TC_SELF_ILLUM } TargetColor;

typedef struct {
    NISINGLEINTERPCTLR controller;
    TargetColor targetColor;
} NiLightColorCtlr <name="NiLightColorController">;

typedef NIBOOLINTERPCTLR NiVisCtlr <name="NiVisController", open=false>;

typedef struct {
    NIEXTRADATACTLR controller;
    STRING extraData;
} NiFloatEDCtlr <name="NiFloatExtraDataController">;

typedef struct {
    // NiControllerSequence::InterpArrayItem
    Ref interpolator;
    Ref controller;
    byte priority;
    // NiControllerSequence::IDTag
    STRING AVObjectName;
    STRING propertyType;
    STRING controllerType;
    STRING controllerID;
    STRING interpolatorID;
} ControlledBlock <name="Controlled Block">;

typedef enum <uint> { LOOP, REVERSE, CLAMP, MAX_CYCLE_TYPES } CycleType;

typedef struct {
    STRING name;
    uint numBlocks;
    uint arrayGrowBy;
    if ( numBlocks > 0 )
        ControlledBlock block[numBlocks];
    float weight;
    Ref textKey;
    CycleType cycleType;
    float frequency;
    float beginKeyTime;
    float endKeyTime;
    Ref owner; // NiControllerManager
    STRING accumRootName;
    if ( stream <= 28 )
        Ref animNotes; // BSAnimNotes
    if ( stream > 28 )
        RefArray16 animNotes( "Anim Notes" ) <optimize=false>; // BSAnimNotes.. Multidimensional?
} NiControllerSequence <name="NiControllerSequence">;

typedef struct {
    NITIMECTLR controller;
    bool cumulativeAnim;
    RefArray sequence( "Sequence" ); // NiSequence
    Ref objectPalette;
} NiControllerMgr <name="NiControllerManager">;

typedef struct {
    NITIMECTLR controller;
    Ref interpolator; // NiKeyframeData
} NiTransCtlr <name="NiTransformController">;

typedef struct {
    NIINTERPCTLR controller;
    RefArray16 targets( "Target" ); // NiAVObject
} NiMultiTransCtlr <name="NiMultiTargetTransformController">;

typedef struct {
    NITIMECTLR controller;
    Ref interpolator; // NiFloatInterpolator
} BSFrustumCtlr <name="BSFrustumFOVController">;

typedef struct {
    NIFLOATINTERPCTLR controller;
    BSLSPControlledVariable controlledVariable;
} BSLSPFloatCtlr <name="BSLightingShaderPropertyFloatController">;

typedef struct {
    NIFLOATINTERPCTLR controller;
    BSLSPControlledColor controlledColor;
} BSLSPColorCtlr <name="BSLightingShaderPropertyColorController">;

typedef struct {
    NIFLOATINTERPCTLR controller;
    BSESPControlledVariable controlledVariable;
} BSESPFloatCtlr <name="BSEffectShaderPropertyFloatController">;

typedef struct {
    NIFLOATINTERPCTLR controller;
    BSESPControlledColor controlledColor;
} BSESPColorCtlr <name="BSEffectShaderPropertyColorController">;

typedef NIFLOATINTERPCTLR NiAlphaCtlr <name="NiAlphaController", open=false>;
typedef NiAlphaCtlr BSNiAlphaCtlr <name="BSNiAlphaPropertyTestRefController", open=false>;

typedef NIFLOATINTERPCTLR NiLightRadiusCtlr <name="NiLightRadiusController", open=false>;
typedef NIFLOATINTERPCTLR NiLightDimmerCtlr <name="NiLightDimmerController", open=false>;

// NiBoneLODController
typedef struct {
    NITIMECTLR controller;
    uint LOD;
    uint numLODs;
    uint boneArraySize;
    if ( boneArraySize > 0 ) {
        struct {
            struct {
                RefArray node( "Node" );
            } nodeSet[boneArraySize] <optimize=false>;
        } boneArray;
    }
} NiBoneLODCtlr <name="NiBoneLODController">;

typedef NiBoneLODCtlr NiBSBoneLODCtlr <name="NiBSBoneLODController">;

// BSLagBoneController
typedef struct {
    NITIMECTLR controller;
    float linearVelocity;
    float linearRotation;
    float maxDistance;
} BSLagBoneCtlr <name="BSLagBoneController">;

// BSProceduralLightningController
typedef struct {
    NITIMECTLR controller;
    Ref generationInterp;
    Ref mutationInterp;
    // Generation
    Ref subdivisionInterp;
    Ref numBranchesInterp;
    Ref numBranchesVarInterp;
    // Process
    Ref lengthInterp;
    Ref lengthVarInterp;
    Ref widthInterp;
    Ref arcOffsetInterp;
    // Generation Params
    ushort subdivisions;
    ushort numBranches;
    ushort numBranchesVariation;
    // Process Params
    float length;
    float lengthVariation;
    float width;
    float childWidthMult;
    float arcOffset;
    bool fadeMainBolt;
    bool fadeChildBolts;
    bool animateArcOffset;
    Ref shaderProperty;
} BSPLightningCtlr <name="BSProceduralLightningController">;

// DATA

typedef struct ( KeyType i ) {
    float time;
    Vec3 value;
    if ( i == 2 ) {
        Vec3 forward;
        Vec3 backward;
    }
    if ( i == 3 )
        TBC tbc;
} Vec3Key <name="Vector3 Key">;

typedef struct {
    uint numKeys;
    if ( numKeys > 0 ) {
        KeyType interpolation;
        if ( numKeys > 0 )
            Vec3Key key(interpolation)[numKeys] <optimize=true>;
    }
} Vec3KeyGrp <name="Keys">;

typedef struct ( KeyType i ) {
    float time;
    Vec4 value;
    if ( i == 2 ) {
        Vec4 forward;
        Vec4 backward;
    }
    if ( i == 3 )
        TBC tbc;
} Vec4Key <name="Vector4 Key">;

typedef struct {
    uint numKeys;
    if ( numKeys > 0 ) {
        KeyType interpolation;
        if ( numKeys > 0 )
            Vec4Key key(interpolation)[numKeys] <optimize=true>;
    }
} Vec4KeyGrp <name="Keys">;

typedef struct ( KeyType i ) {
    float time;
    float value;
    if ( i == 2 ) {
        float forward;
        float backward;
    }
    if ( i == 3 )
        TBC tbc;
} FloatKey <name="Float Key">;

typedef struct {
    uint numKeys;
    if ( numKeys > 0 ) {
        KeyType interpolation;
        if ( numKeys > 0 )
            FloatKey key(interpolation)[numKeys] <optimize=true>;
    }

} FloatKeyGrp <name="Keys">;

typedef struct ( KeyType i ) {
    float time;
    byte value;
    if ( i == 2 ) {
        byte forward;
        byte backward;
    }
    if ( i == 3 )
        TBC tbc;
} ByteKey <name="Byte Key">;

typedef struct {
    uint numKeys;
    if ( numKeys > 0 ) {
        KeyType interpolation;
        if ( numKeys > 0 )
            ByteKey key(interpolation)[numKeys] <optimize=true>;
    }
} ByteKeyGrp <name="Keys">;

typedef struct ( KeyType i ) {
    float time;
    STRING value;
    if ( i == 2 ) {
        STRING forward;
        STRING backward;
    }
    if ( i == 3 )
        TBC tbc;
} StringKey <name="String Key">;

typedef struct {
    uint numKeys;
    if ( numKeys > 0 ) {
        KeyType interpolation;
        if ( numKeys > 0 )
            StringKey key(interpolation)[numKeys] <optimize=true>;
    }
} StringKeyGrp <name="Keys">;

typedef struct {
    uint numRotKeys;
    if ( numRotKeys > 0 )
    {
        KeyType rotType;
        if ( rotType != XYZ_ROTATION_KEY )
            Vec4Key rotations(rotType)[numRotKeys] <optimize=true>;
        else if ( rotType == XYZ_ROTATION_KEY ) {
            FloatKeyGrp rotations[3] <optimize=false>;
        }
            
    }
    Vec3KeyGrp translations;
    FloatKeyGrp scales;
} NiKFData <name="NiKeyFrameData">;

typedef struct {
    NiKFData data;
} NiTransformData <name="NiTransformData">;

typedef struct {
    Vec3KeyGrp positions;
} NiPosData <name="NiPosData">;

typedef struct {
    ByteKeyGrp data;
} NiByteData;
typedef NiByteData NiBoolData <name="NiBoolData">;

typedef struct {
    FloatKeyGrp data;
} NiFloatData <name="NiFloatData">;


// INTERPOLATORS

typedef struct {
    enum <byte> { MANAGER_CONTROLLED = 1 } flags;
    byte arraySize;
    float weightThreshold;
    if ( !(flags & 1) ) {
        byte interpCount;
        byte singleIndex;
        char highPriority;
        char nextHighPriority;
        float singleTime;
        float highSumOfWeights;
        float nextHighSumOfWeights;
        float highEaseSpinner;
        if ( arraySize ) {
            struct {
                Ref interpolator;
                float weight;
                float normalizedWeight;
                byte priority;
                float easeSpinner;
            } interpArrayItem[arraySize] <optimize=true>;
        }
    }
} NIBLENDINTERP <open=true>; // Abstract

typedef struct {
    byte value; // NiBool value of 2 means Invalid, basically the "undefined" value like uint/float
    Ref data; // NiBoolData
} NiBoolInterp <name="NiBoolInterpolator">;

typedef NiBoolInterp NiBoolTimeInterp <name="NiBoolTimelineInterpolator">;

typedef struct {
    NIBLENDINTERP blend;
    byte value;
} NiBlendBool <name="NiBlendBoolInterpolator">;

typedef struct {
    float value;
    Ref data; // NiFloatData
} NiFloatInterp <name="NiFloatInterpolator">;

typedef struct {
    NIBLENDINTERP blend;
    float value;
} NiBlendFloat <name="NiBlendFloatInterpolator">;

typedef struct {
    NiQuatTransform transform;
    Ref data; // NiTransformData
} NiTransformInterp <name="NiTransformInterpolator">;

typedef struct {
    Vec3 point;
    Ref data; // NiPosData
} NiPoint3Interp <name="NiPoint3Interpolator">;

typedef struct {
    NIBLENDINTERP blend;
    Vec3 point;
} NiBlendPoint3 <name="NiBlendPoint3Interpolator">;

typedef struct {
    enum <ushort> {
        LOOK_X_AXIS = 0,
        LOOK_FLIP = 1,
        LOOK_Y_AXIS = 2,
        LOOK_Z_AXIS = 4
    } flags; // Should be a bitfield for flip toggle
    Ref lookAt;
    STRING lookAtName;
    NiQuatTransform transform;
    Ref translateInterp;
    Ref rollInterp;
    Ref scaleInterp;
} NiLookAtInterp <name="NiLookAtInterpolator">;

// TODO: Needs to be changed to bitfield
typedef enum <ushort> {
    CVDataNeedsUpdate = 0x1,
    CurveTypeOpen = 0x2,
    AllowFlip = 0x4,
    Bank = 0x8,
    ConstantVelocity = 0x10,
    Follow = 0x20,
    Flip = 0x40
} PathFlags;

// NiPathInterpolator
typedef struct {
    PathFlags flags;
    uint bankDir;
    float maxBankAngle;
    float smoothing;
    ushort followAxis;
    Ref pathData; // NiPosData
    Ref percentData; // NiFloatData
} NiPathInterp <name="NiPathInterpolator">;


// Legacy Anim

typedef NIFLOATINTERPCTLR NiAlphaController <name="NiAlphaController", open=false>;
typedef NIFLOATINTERPCTLR BSMatEmitMultCtlr <name="BSMaterialEmittanceMultController", open=false>;
typedef NIFLOATINTERPCTLR BSRefractionStrCtlr <name="BSRefractionStrengthController", open=false>;
typedef NiLightColorCtlr NiMaterialColorCtlr <name="NiMaterialColorController">;

typedef struct {
    NIFLOATINTERPCTLR controller;
    byte unkByte;
    uint texType;
    uint texTransType;
} NiTextureTransformCtlr <name="NiTextureTransformController">;

typedef struct ( uint numVerts ) {
    STRING frameName;
    if ( numVerts > 0 )
        Vec3 vector[numVerts];
} Morph;

typedef struct {
    uint numMorphs;
    uint numVertices;
    bool relativeTargets;
    if ( numMorphs > 0 )
        Morph morph(numVertices)[numMorphs] <optimize=true>;
} NiMorphData <name="NiMorphData">;

typedef struct {
    Vec4KeyGrp data; // Color4
} NiColorData <name="NiColorData">;

typedef struct {
    NIINTERPCTLR controller;
    ushort flags; // flags & 1 == updateNormals
    Ref data; // NiMorphData
    bool alwaysUpdate;
    uint numTargets;
    if ( numTargets > 0 )
        struct {
            Ref interpolator;
            float weight;
        } interpItem[numTargets];
} NiGeomMorpherCtlr <name="NiGeomMorpherController">;

typedef struct {
    NITIMECTLR controller;
    uint keys;
} bhkBlendController <name="bhkBlendController">;

typedef enum<uint> {
    ANT_INVALID = 0,
    ANT_GRABIK = 1,
    ANT_LOOKIK = 2
} AnimNoteType;

typedef struct {
    AnimNoteType type; // BSAnimNote::AnimNoteType
    float time;
    if ( type == ANT_GRABIK )
        uint arm; // GRABIK_ARM
    if ( type != ANT_INVALID ) {
        float gain;
        uint state; // GRABIK_STATE / LOOKIK_STATE
    }
} BSAnimNote <name="BSAnimNote">;

typedef struct {
    RefArray16 animNotes( "Anim Note" ); // BSAnimNote
} BSAnimNotes <name="BSAnimNotes">;

