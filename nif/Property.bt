//------------------------------------------------
//--- 010 Editor v7.0.2 Binary Template
//
//      File: Property.bt
//   Authors: jonwd7
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

typedef NiObjectNET NiProperty <name="NiProperty">;
typedef NiObjectNET NiTexture <name="NiTexture">;

typedef struct {
    NiProperty prop;
    ushort flags;
} NiDitherProperty <name="NiDitherProperty">;

typedef struct {
    NiProperty prop;
    ushort flags; // SetFog true == flags |= 1, GetFogFunction == (flags >> 1) & 3
    float depth;
    Color3 color;
} NiFogProperty <name="NiFogProperty">;

typedef struct {
    NiProperty prop;
    if ( stream < 26 ) {
        Color3 ambient;
        Color3 diffuse;
    }
    Color3 specular;
    Color3 emissive;
    float glossiness;
    float alpha;
    if ( stream > 21 )
        float emissiveMult;
} NiMaterialProperty <name="NiMaterialProperty">;

typedef struct {
    NiProperty prop;
    ushort flags;
} NiSpecularProperty <name="NiSpecularProperty">;

typedef struct {
    NiProperty prop;
    if ( version < Version(20, 1, 0, 2) ) {
        bool enable;
        uint testFunction; // ENUM
        uint ref;
        uint mask;
        uint stencilFailAction; // ENUM
        uint stencilPassZFailAction; // ENUM
        uint stencilPassAction; // ENUM
        uint drawMode; // ENUM
    } else {
        ushort flags;
        uint ref;
        uint mask;
    }
} NiStencilProperty <name="NiStencilProperty">;

typedef struct {
    NiProperty prop;
    ushort flags;
    if ( version < Version(20, 1, 0, 2) ) {
        enum <uint> {
            SOURCE_IGNORE,
            SOURCE_EMISSIVE,
            SOURCE_AMB_DIFF
        } sourceVertexMode;
        enum <uint> {
            LIGHTING_E,
            LIGHTING_E_A_D
        } lightingMode;
    }
} NiVertexColorProperty <name="NiVertexColorProperty">;

typedef struct {
    NiProperty prop;
    ushort flags;
} NiWireframeProperty <name="NiWireframeProperty">;

typedef struct {
    NiProperty prop;
    ushort flags;
    if ( version < Version(20, 1, 0, 2) )
        enum <uint> {
            TEST_ALWAYS,
            TEST_LESS,
            TEST_EQUAL,
            TEST_LESSEQUAL,
            TEST_GREATER,
            TEST_NOTEQUAL,
            TEST_GREATEREQUAL,
            TEST_NEVER
        } testFunction;
} NiZBufferProperty <name="NiZBufferProperty">;

typedef struct {
    NiTexture tex;
    bool useExternal;
    STRING filename;
    Ref data; // NiPixelData if < 20.2.0.4 or !persistentRenderData
              // else NiPersistentSrcTextureRendererData
    PixelLayout pixelLayout;
    MipMapFormat mipMapFormat;
    AlphaFormat alphaFormat;
    bool isStatic;
    if ( version >= Version(10, 1, 0, 103) )
        bool directRender;
    if ( version >= Version(20, 2, 0, 4) )
        bool persistentRenderData;
} NiSourceTexture <name="NiSourceTexture">;

typedef NiSourceTexture NiSourceCubeMap <name="NiSourceCubeMap">;

typedef struct {
    TexCoord translation;
    TexCoord scale;
    float rotation;
    enum TransformMethod {
        MAYA_DEPRECATED_TRANSFORM = 0,
        MAX_TRANSFORM,
        MAYA_TRANSFORM
    } transformMethod;
    TexCoord center;
} TexTransform;

typedef struct {
    Ref source;
    if ( version < Version(20, 1, 0, 2) ) {
        ClampMode clampMode;
        FilterMode filterMode;
        uint texCoordIndex;
        if ( version < Version(10, 3, 0, 4) )
            short LandK[2];
    } else {
        ushort flags;
    }

    if ( version >= Version(20, 5, 0, 4) )
        ushort maxAnisotropy;
    bool hasTexTransform;
    if ( hasTexTransform )
        TexTransform transform;
} Tex;

typedef struct {
    bool isUsed;
    if ( isUsed ) {
        Tex data;
        uint mapIndex;
    }
} ShaderTex;

typedef struct {
    NiProperty prop;
    if ( version < Version(20, 1, 0, 2) )
        uint applyMode; // ENUM
    else
        ushort flags;

    uint textureCount;
    bool hasBaseTex;
    if ( hasBaseTex )
        Tex baseTex;
    bool hasDarkTex;
    if ( hasDarkTex )
        Tex darkTex;
    bool hasDetailTex;
    if ( hasDetailTex )
        Tex detailTex;
    bool hasGlossTex;
    if ( hasGlossTex )
        Tex glossTex;
    bool hasGlowTex;
    if ( hasGlowTex )
        Tex glowTex;
    bool hasBumpTex;
    if ( hasBumpTex ) {
        Tex bumpTex;
        float lumaScale;
        float lumaOffset;
        Vec4 bumpMatrix;
    }

    if ( textureCount > 6 ) {
        bool hasNormalTex;
        if ( hasNormalTex )
            Tex normalTex;
    }

    if ( textureCount > 7 ) {
        bool hasUnkTex;
        if ( hasUnkTex ) {
            Tex unkTex;
            float unkFloat;
        }
    }

    if ( textureCount > 8 ) {
        bool hasDecalTex0;
        if ( hasDecalTex0 )
            Tex decalTex0;
    }
    
    if ( textureCount > 9 ) {
        bool hasDecalTex1;
        if ( hasDecalTex1 )
            Tex decalTex1;
    }
    if ( textureCount > 10 ) {
        bool hasDecalTex2;
        if ( hasDecalTex2 )
            Tex decalTex2;
    }
    if ( textureCount > 11 ) {
        bool hasDecalTex3;
        if ( hasDecalTex3 )
            Tex decalTex3;
    }
    
    uint numShaderTex;
    if ( numShaderTex > 0 ) {
        ShaderTex shaderTex[numShaderTex] <optimize=false>;
    }
} NiTexturingProperty <name="NiTexturingProperty">;
