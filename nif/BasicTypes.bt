//------------------------------------------------
//--- 010 Editor v7.0.2 Binary Template
//
//      File: BasicTypes.bt
//   Authors: jonwd7
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

//typedef float float <read=ParseFloat>;

typedef union {
    ushort value;
    struct {
        ushort : 4;
        ushort vertex   : 1;
        ushort uv1      : 1;
        ushort uv2      : 1;
        ushort normal   : 1;
        ushort tangent  : 1;
        ushort color    : 1;
        ushort skinned  : 1;
        ushort landData : 1;
        ushort eyeData  : 1;
        ushort unk      : 1;
        ushort fullprec : 1;
    } bitflags;
} VertexFlags <name="Vertex Flags", read=VertexFlagsRead, open=false>;

string VertexFlagsRead( VertexFlags& f )
{
    string s;

    ushort vf = f.value >> 4;
    
    if ( vf & VF_VERTEX )
        s += "VERTEX | ";
    if ( vf & VF_UV )
        s += "UV_1 | ";
    if ( vf & VF_UV_2 )
        s += "UV_2 | ";
    if ( vf & VF_NORMAL )
        s += "NORMAL | ";
    if ( vf & VF_TANGENT )
        s += "TANGENT | ";
    if ( vf & VF_COLORS )
        s += "COLOR | ";
    if ( vf & VF_SKINNED )
        s += "SKINNED | ";
    if ( vf & VF_LANDDATA )
        s += "LANDDATA | ";
    if ( vf & VF_EYEDATA )
        s += "EYEDATA | ";
    if ( vf & 0x200 )
        s += " UNKNOWN | ";
    if ( vf & VF_FULLPREC )
        s += "FULLPREC | ";

    SPrintf(s, "%s (%u)", s, f.value );
    
    return s;
}

typedef union {
    uint64 value <format=hex>;
    local uint64 flags = value >> 44;
    struct
    {
        // Sizes and Offsets are all multiplied by 4
        byte szVertexData : 4;
        byte szVertex : 4;
        byte oTexCoord0 : 4;
        byte oTexCoord1 : 4;
        byte oNormal : 4;
        byte oTangent : 4;
        byte oColor : 4;
        byte oSkinningData : 4;
        byte oLandscapeData : 4;
        byte oEyeData : 4;
        VertexFlags vertexFlags;
        byte unused;
    } bits <open=true>;
} VertexDesc <read=VertexDescRead, open=true>;

string VertexDescRead( VertexDesc& f )
{
    string s;
    
    SPrintf(s, "%s: %u", "Size", f.bits.szVertexData * 4);

    SPrintf(s, "%s | OFFSETS", s );
    
    if ( f.bits.szVertex > 0 )
        SPrintf(s, "%s | Vertex: DYNAMIC", s);
    else if ( f.flags & VF_VERTEX )
        SPrintf(s, "%s | %s: %u", s, "Vertex", f.bits.szVertex * 4);
    if ( f.flags & VF_UV )
        SPrintf(s, "%s | %s: %u", s, "UV1", f.bits.oTexCoord0 * 4);
    if ( f.flags & VF_UV_2 )
        SPrintf(s, "%s | %s: %u", s, "UV2", f.bits.oTexCoord1 * 4);
    if ( f.flags & VF_NORMAL )
        SPrintf(s, "%s | %s: %u", s, "Normal", f.bits.oNormal * 4);
    if ( f.flags & VF_TANGENT )
        SPrintf(s, "%s | %s: %u", s, "Tangent", f.bits.oTangent * 4);
    if ( f.flags & VF_COLORS )
        SPrintf(s, "%s | %s: %u", s, "Color", f.bits.oColor * 4);
    if ( f.flags & VF_SKINNED )
        SPrintf(s, "%s | %s: %u", s, "Skin", f.bits.oSkinningData * 4);
    if ( f.flags & VF_LANDDATA )
        SPrintf(s, "%s | %s: %u", s, "Land", f.bits.oLandscapeData * 4);
    if ( f.flags & VF_EYEDATA )
        SPrintf(s, "%s | %s: %u", s, "Eye", f.bits.oEyeData * 4);
    return s;
}

typedef ubyte bool;

typedef struct {
    float X;
    float Y;
    float Z;
} Vec3 <read=ReadVec3, open=suppress>;

typedef struct {
    hfloat X;
    hfloat Y;
    hfloat Z;
} HalfVec3 <read=ReadHalfVec3, open=suppress>;

typedef struct {
    byte X;
    byte Y;
    byte Z;
} ByteVec3;

typedef struct {
    float X;
    float Y;
    float Z;
    float W;
} Vec4 <read=ReadVec4, open=suppress>;

typedef struct ( string str ) {
    local string sW = str;
    byte X;
    byte Y;
    byte Z;
    byte W;
} ByteVec4 <read=ReadByteVec4, open=suppress>;

typedef struct {
    float W;
    float X;
    float Y;
    float Z;
} Quat;

typedef Vec4 QuatXYZW;

typedef struct {
    float R;
    float G;
    float B;
} Color3;

typedef struct {
    float R;
    float G;
    float B;
    float A;
} Color4;

typedef struct {
    ubyte R;
    ubyte G;
    ubyte B;
    ubyte A;
} ByteColor4;

typedef struct {
    Vec3 _1;
    Vec3 _2;
    Vec3 _3;
} Matrix33;

typedef struct {
    Vec3 _1;
    Vec3 _2;
    Vec3 _3;
    Vec3 _4;
} Matrix34;

typedef struct {
    Vec4 _1;
    Vec4 _2;
    Vec4 _3;
} Matrix43;

typedef struct {
    Vec4 _1;
    Vec4 _2;
    Vec4 _3;
    Vec4 _4;
} Matrix44;

typedef struct {
    Matrix33 rotation;
    Vec3 translation;
    float scale;
} NiTransform <open=true, name="Transform">;

typedef struct {
    Vec3 translation;
    Quat rotation;
    float scale;
} NiQuatTransform <open=true, name="Transform">;

typedef struct {
    float U;
    float V;
} TexCoord <name="UV", read=ReadTexCoord>;

typedef struct ( uint numVerts ) {
    TexCoord uv[numVerts];
} TexCoordArray <name="UVs">;

typedef struct {
    hfloat U;
    hfloat V;
} HalfTexCoord <name="UV", read=ReadHalfTexCoord>;

typedef struct {
    ushort A;
    ushort B;
    ushort C;
} Triangle <read=ReadTriangle, open=suppress>;

typedef struct {
    float t;
    float b;
    float c;
} TBC;

typedef struct {
    Vec3 center;
    float radius;
} NiBound;

typedef struct {
    ushort size;
    if ( size > 0 )
        ushort index[size];
} IndexArray16;

typedef struct {
    uint size;
    if ( size > 0 )
        byte data[size] <open=suppress>;
} BinaryData <open=suppress>;


// ubyte wrapper for UByteArray
typedef struct ( string str ) {
    local string name = str;
    ubyte item;
} _ubyte <name=UByteName, read=UByteRead>;

string UByteName ( _ubyte& b ) { return b.name; }
string UByteRead ( _ubyte& b )
{
    string s;
    SPrintf(s, "%u", b.item);
    return s;
}

// ushort wrapper for UShortArray
typedef struct ( string str ) {
    local string name = str;
    ushort item;
} _ushort <name=UShortName, read=UShortRead>;

string UShortName ( _ushort& b ) { return b.name; }
string UShortRead ( _ushort& b )
{
    string s;
    SPrintf(s, "%u", b.item);
    return s;
}

// uint wrapper for UIntArray
typedef struct ( string str ) {
    local string name = str;
    uint item;
} _uint <name=UIntName, read=UIntRead>;

string UIntName ( _uint& b ) { return b.name; }
string UIntRead ( _uint& b )
{
    string s;
    SPrintf(s, "%u", b.item);
    return s;
}

// float wrapper for FloatArray
typedef struct ( string str ) {
    local string name = str;
    float item;
} _float <name=FloatName, read=FloatRead>;

string FloatName ( _float& f ) { return f.name; }
string FloatRead ( _float& f )
{
    string s;
    SPrintf(s, "%f", f.item);
    return s;
}

// For Multi-dimensional ubyte arrays whose member names can be supplied
typedef struct ( uint n, string str ) {
    _ubyte item(str)[n] <name=UByteArrayItemRead, optimize=false>; // Optimize true hides the values
} UByteArray <open=suppress, optimize=false>;

string UByteArrayItemRead ( _ubyte& i ) { return i.name; }

// For Multi-dimensional ubyte arrays whose member names can be supplied
typedef struct ( uint n, string str ) {
    _ushort item(str)[n] <name=UShortArrayItemRead, optimize=false>;
} UShortArray <open=suppress, optimize=false>;

string UShortArrayItemRead ( _ushort& i ) { return i.name; }

// For Multi-dimensional uint arrays whose member names can be supplied
typedef struct ( uint n, string str ) {
    _uint item(str)[n] <name=UIntArrayItemRead, optimize=false>;
} UIntArray <open=suppress, optimize=false>;

string UIntArrayItemRead ( _uint& i ) { return i.name; }

// For Multi-dimensional float arrays whose member names can be supplied
typedef struct ( uint n, string str ) {
    _float item(str)[n] <name=FloatArrayItemRead, optimize=false>;
} FloatArray <open=suppress, optimize=false>;

string FloatArrayItemRead ( _float& i ) { return i.name; }


// STRINGINDEX
typedef uint STRINGINDEX <read=ReadSTRINGINDEX>;

string ReadSTRINGINDEX ( STRINGINDEX &s ) {
    if ( s == -1 )
        return "";

    string t;
    SPrintf(t, "%s [%u]", file.header.strs[s].str, s);
    return t;
}

string ReadSTRINGINDEXLocal ( STRINGINDEX &s ) {
    if ( s == -1 )
        return "";
    local string t;
    SPrintf(t, "%s", file.header.strs[s].str);
    return t;
}

// SSTRING
typedef struct {
    uint stringlength <hidden=true>;
    if ( stringlength > 0 )
        char str[stringlength] <open=suppress>;
    else
        local char str = '\0';
} SSTRING <read=ReadSSTRING>;

string ReadSSTRING( SSTRING &s )
{
    return s.str;
}

// STRING (Combine STRINGINDEX and SSTRING)
typedef struct {
    local string nameStr;
    if ( version < Version(20, 1, 0, 1) ) {
        SSTRING name;
        nameStr = ReadSSTRING( name );
    } else {
        STRINGINDEX name;
        nameStr = ReadSTRINGINDEXLocal( name );
    }
} STRING <read=ReadSTRING>;

string ReadSTRING( STRING &s )
{
    return s.nameStr;
}

// SSTRING16
typedef struct {
    ushort stringlength <hidden=true>;
    if ( stringlength > 0 )
        char str[stringlength] <open=suppress>;
    else
        local char str = '\0';
} SSTRING16 <read=ReadSSTRING16>;

string ReadSSTRING16( SSTRING16 &s )
{
    return s.str;
}

// SSTRING8
typedef struct {
    uchar stringlength <hidden=true>;
    if ( stringlength > 0 )
        char str[stringlength] <open=suppress>;
    else
        local char str = '\0';
} SSTRING8 <read=ReadSSSTRING8>;

string ReadSSSTRING8( SSTRING8 &s )
{
    return s.str;
}

enum 
{
    SKIPPABLE_MASK = 0x8000
};

// BLOCKTYPEINDEX
typedef struct  {
    ushort indexRaw;
    local ushort index = indexRaw & ~(SKIPPABLE_MASK);
} BLOCKTYPEINDEX <read=ReadBLOCKTYPEINDEX>;

string ReadBLOCKTYPEINDEX( BLOCKTYPEINDEX &b )
{
    string s;
    SPrintf(s, "%s", file.header.btype[b.index].str);
    return s;
}

// Ref
typedef uint Ref <read=ReadREF, open=suppress>;

string ReadREF ( Ref &r )
{
    if ( r == 4294967295 )
        return "None";

    string n;
    string t = file.header.btype[file.header.btypeindex[r].index].str;
    if ( exists(file.blocks.data[r].base.name.nameStr) ) {
        n = file.blocks.data[r].base.name.nameStr;
    } else if ( exists(file.blocks.data[r].base.nameStr) ) {
        n = file.blocks.data[r].base.nameStr;
    }

    string s;
    SPrintf(s, "%s [%u] (%s)", t, r, n);

    return s;
}

// Ref Array
typedef struct ( string str ) {
    local string name = str;
    uint size;
    if ( size > 0 )
        Ref ref[size] <name=RefArrayItemName, open=true, optimize=false>;
} RefArray;

// Ref Array (16-bit Size)
typedef struct ( string str ) {
    local string name = str;
    ushort size;
    if ( size > 0 )
        Ref ref[size] <name=RefArrayItemName, open=true, optimize=false>;
} RefArray16;

string RefArrayItemName ( Ref& i ) { return parentof(i).name; }

// BASIC READ FUNCTIONS

string ParseFloat( float& f )
{
    string s;
    // -FLT_MAX = FF FF 7F FF, +FLT_MAX = FF FF 7F 7F
    uchar n[4] = { 0xFF, 0xFF, 0x7F, 0xFF };
    uchar p[4] = { 0xFF, 0xFF, 0x7F, 0x7F };

    uchar b[4];
    ConvertDataToBytes( f, b );

    if ( b == p )
        s = "+FLT_MAX";
    else if ( b == n )
        s = "-FLT_MAX";
    else
        SPrintf(s, "%f", f);

    return s;
}

string ReadTexCoord( TexCoord& uv )
{
    string s;
    SPrintf(s, "U %f V %f", uv.U, uv.V);
    return s;
}

string ReadHalfTexCoord( HalfTexCoord& uv )
{
    string s;
    SPrintf(s, "U %f V %f", uv.U, uv.V);
    return s;
}

string ReadVec3( Vec3& vec )
{
    string s;
    SPrintf(s, "X %s Y %s Z %s", ParseFloat(vec.X), ParseFloat(vec.Y), ParseFloat(vec.Z));
    return s;
}

string ReadVec4( Vec4& vec )
{
    string s;
    SPrintf(s, "X %s Y %s Z %s W %s", ParseFloat(vec.X), ParseFloat(vec.Y), 
                                      ParseFloat(vec.Z), ParseFloat(vec.W)
    );
    return s;
}

string ReadHalfVec3( HalfVec3& vec )
{
    string s;
    SPrintf(s, "X %f Y %f Z %f", vec.X, vec.Y, vec.Z);
    return s;
}

string ReadByteVec4( ByteVec4& vec )
{
    string s;
    float x, y, z, w;
    x = (vec.X / 255.0);
    y = (vec.Y / 255.0);
    z = (vec.Z / 255.0);
    w = (vec.W / 255.0);

    SPrintf(s, "X %f Y %f Z %f | %s: %f", x, y, z, vec.sW, w);
    return s;
}

string ReadTriangle( Triangle& t )
{
    string s;
    SPrintf(s, "%u %u %u", t.A, t.B, t.C);
    return s;
}
