//------------------------------------------------
//--- 010 Editor v7.0.2 Binary Template
//
//      File: bhk.bt
//   Authors: jonwd7
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

typedef struct {
    byte data;
} FlagPart <name="Flags and Part Number">;

typedef struct {
    Ref shape;
    if ( stream < 83 )
        FO3Layer layer;
    else if ( stream == 83 || stream == 100 )
        SkyrimLayer layer;
    else
        OblivionLayer layer;
    FlagPart flags;
    ushort unk;
} bhkWorldOBJ <open=true>;

typedef struct {
    bhkWorldOBJ obj;
    int unknownInt1;
    int unknownInt2;
    int unknown3Ints[3];
    hkResponseType collisionResponse;
    ubyte unknownByte;
    ushort callbackDelay;
    ushort unknown2shorts[2];
    if ( stream < 83 )
        FO3Layer layerCopy;
    else if ( stream == 83 || stream == 100 )
        SkyrimLayer layerCopy;
    else
        OblivionLayer layerCopy;
    byte colFilterCopy;
    ushort unknown7shorts[7];
    Vec4 translation;
    QuatXYZW rotation;
    Vec4 linearVel;
    Vec4 angularVel;
    Matrix43 inertia;
    Vec4 center;
    float mass;
    float linearDamping;
    float angularDamping;

    if ( stream > 34 ) {
        float unknownTimeFactor;
        float unknownTimeFactor2;
    }

    float friction;
    if ( stream > 34 )
        float rollingFrictionMult;
    float restitution;
    float maxLinearVel;
    float maxAngularVel;
    float penDepth;
    byte motionSystem;
    byte deactivatorType;
    byte solverDeactivation;
    byte qualityType;
    uint unknownInt6;
    uint unknownInt7;
    uint unknownInt8;
    if ( stream > 34 )
        uint unknownInt81;
    uint numConstraints;
    if ( numConstraints > 0 )
        Ref constraints[numConstraints] <optimize=false>;
    
    if ( stream <= 34 )
        uint wind;
    else
        ushort wind;
} bhkRigidBody <name="bhkRigidBody">;

typedef bhkRigidBody bhkRigidBodyT <name="bhkRigidBodyT">;

// OBJECTS

typedef struct {
    Ref target;
    ushort flags;
    Ref body;
} bhkCollisionObj <name="bhkCollisionObject">;

typedef struct {
    Ref target;
    ushort flags;
    Ref data;
    uint bodyID;
} bhkNPCollObj <name="bhkNPCollisionObject">;

typedef bhkCollisionObj bhkSPCollObj <name="bhkSPCollisionObject">;

// SHAPES

typedef struct {
    uint numShapes;
    if ( numShapes > 0 )
        Ref shape[numShapes];
    uint HavokMaterial; // enum
    float unkFloats[6];
    uint numUnk;
    if ( numUnk > 0 )
        uint unkInts[numUnk];
} bhkListShape <name="bhkListShape">;

typedef struct {
    uint HavokMaterial; // enum
    float radius;
} bhkConvexShape <open=true>; // Abstract

typedef struct {
    uint HavokMaterial;
    float radius;
    float unkFloats[14];
} bhkPlaneShape <name="bhkPlaneShape">;

typedef bhkConvexShape bhkSphereShape <name="bhkSphereShape", open=false>;

typedef struct {
    bhkConvexShape shape;
    uint unkInt1;
    uint unkInt2;
    Vec3 dimensions;
    float radius;
} bhkBoxShape <name="bhkBoxShape">;

typedef struct {
    bhkConvexShape shape;
    uint unkInt1;
    uint unkInt2;
    Vec3 point1;
    float radius1;
    Vec3 point2;
    float radius2;
} bhkCapsuleShape <name="bhkCapsuleShape">;

typedef struct {
    bhkWorldOBJ obj;
    float unkData[23];
} bhkSSPhantom <name="bhkSimpleShapePhantom">;

typedef struct {
    uint mat;
    float radius;
    float unknown[6];
    uint numVerts;
    if ( numVerts > 0 )
        Vec4 verts[numVerts] <optimize=true>;
    uint numNormals;
    if ( numNormals > 0 )
        Vec4 normals[numNormals] <optimize=true>;
} bhkCVS <name="bhkConvexVerticesShape">;

typedef struct {
    Ref shape;
    uint HavokMaterial; // Enum
    float radius;
    uint unkInt1;
    uint unkInt2;
    Matrix44 transform;
} bhkTS <name="bhkTransformShape">;

typedef bhkTS bhkCTS <name="bhkConvexTransformShape">;

typedef struct {
    Ref shape;
    uint unkInt1;
    uint unkInt2;
    uint unkInt3;
    float unkFloat1;
    uint dataSize;
    Vec3 origin;
    float scale;
    if ( stream > 34 )
        byte buildType;
    if ( dataSize > 0 )
        byte data[dataSize];
} bhkMoppBVShape <name="bhkMoppBvTreeShape">;

typedef struct {
    Ref target;
    uint unk; // either "userData" or "pObject"
    float radius;
    float unkFloat;
    Vec4 unkVec4;
    float radius;
    float scale;
    float unkFloats[3];
    Ref data;
} bhkCMS <name="bhkCompressedMeshShape">;

typedef struct {
    uint skyrimMat;
    uint unknown;
} bhkCMSDMat;

typedef struct {
    Vec4 translation;
    QuatXYZW rotation;
} bhkCMSDTrans;

typedef struct {
    ushort triA;
    ushort triB;
    ushort triC;
    uint material;
    ushort weldingInfo;
} bhkCMSDBT;

typedef struct {
    Vec4 translation;
    uint matIndex; // m_materialInfo
    ushort reference;
    ushort transformIndex;
    uint numVerts;
    if ( numVerts > 0 )
        ushort verts[numVerts] <optimize=false>;
    uint numIndices;
    if ( numIndices > 0 )
        ushort indices[numIndices] <optimize=false>;
    uint numStrips;
    if ( numStrips > 0 )
        ushort strips[numStrips] <optimize=false>;
    uint numWeldingInfo;
    if ( numWeldingInfo > 0 )
        ushort weldingInfo[numWeldingInfo] <optimize=false>;
    
} bhkCMSDChunk;

typedef struct {
    uint bitsPerIndex;
    uint bitsPerWIndex;
    uint maskWIndex;
    uint maskIndex;
    float error;
    Vec4 boundsMin;
    Vec4 boundsMax;
    byte weldingType;
    byte materialType;
    // Mat32A, Mat16A, and Mat8A do not appear to ever be used
    uint numMat32;
    if ( numMat32 > 0 )
        uint mat32[numMat32] <optimize=true>;
    uint numMat16;
    if ( numMat16 > 0 )
        uint mat16[numMat16] <optimize=true>;
    uint numMat8;
    if ( numMat8 > 0 )
        uint mat8[numMat8] <optimize=true>;

    uint numMaterials;
    bhkCMSDMat materials[numMaterials] <optimize=false>;

    // NamedMat does not appear to ever be used
    uint numNamedMat;
    // Needs Array

    uint numTransforms;
    if ( numTransforms > 0 )
        bhkCMSDTrans transforms[numTransforms] <optimize=false>;

    uint numBigVerts;
    if ( numBigVerts > 0 )
        Vec4 bigVerts[numBigVerts] <optimize=false>;

    uint numBigTris;
    if ( numBigTris > 0 )
        bhkCMSDBT bigTris[numBigTris] <optimize=false>;

    uint numChunks;
    bhkCMSDChunk chunks[numChunks] <optimize=false>;

    // ConvexPiece does not appear to ever be used
    uint numConvexPieceA;
    // Needs Array

} bhkCMSD <name="bhkCompressedMeshShapeData">;


// CONSTRAINTS

typedef struct {
    Vec4 axleA;
    Vec4 axleInA1;
    Vec4 axleInA2;
    Vec4 pivotA;
    Vec4 axleB;
    Vec4 axleInB1;
    Vec4 axleInB2;
    Vec4 pivotB;
} bhkHinge <open=true>; // Abstract

typedef struct {
    float unk[6];
    byte unkByte;
} bhkMotor;

typedef struct {
    bhkHinge hinge <open=true>;
    float minAngle;
    float maxAngle;
    float maxFriction;
    bool enableMotor;
    if ( enableMotor == 1 )
        bhkMotor motor;
} bhkLimitedHinge <open=true>; // Abstract

typedef struct {
    uint numEntities;
    if ( numEntities > 0 )
       Ref entity[numEntities];
    uint priority;
} bhkConstraint <open=true>; // Abstract

typedef struct {
    bhkConstraint base;
    bhkHinge hinge;
} bhkHingeConstraint <name="bhkHingeConstraint">;

typedef struct {
    bhkConstraint base;
    bhkLimitedHinge hinge;
} bhkLHConstraint <name="bhkLimitedHingeConstraint">;


// SYSTEMS

typedef BinaryData bhkPhysSystem <name="bhkPhysicsSystem">;
typedef BinaryData bhkRagSystem <name="bhkRagdollSystem">;
